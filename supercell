import numpy as np

def generate_lammps_positions(vectors, bases, repetitions, output_file="atoms.lmp", lattice_param=1.0):
    vectors = np.array(vectors) * lattice_param
    bases = np.array(bases)
    nx_negative, nx_positive, ny_negative, ny_positive, nz_negative, nz_positive = repetitions


    positions = []

    centers = [np.zeros(3)]

    # Gerar as posições
    for center in centers:
      for i in range(-nx_negative, nx_positive ):  # Repetições no eixo x
        for j in range(-ny_negative, ny_positive ):  # Repetições no eixo y
            for k in range(-nz_negative, nz_positive ):  # Repetições no eixo z
                translation_x = i * vectors[0]  # Translação no eixo x
                while translation_x[1]>= np.linalg.norm(vectors[1]):
                  translation_x[1] -= np.linalg.norm(vectors[1])
                while translation_x[1]< 0:
                  translation_x[1] += np.linalg.norm(vectors[1])
                translation_y = j * vectors[1]  # Translação no eixo y

                translation = translation_x + translation_y + k * vectors[2]

                for base in bases:
                    # Calcular a posição ajustada
                    position = (
                        center
                        + translation
                        + base[0] * vectors[0]
                        + base[1] * vectors[1]
                        + base[2] * vectors[2]
                    )

                    # Adicionar a posição se não for duplicada
                    if not any(np.allclose(position, existing, atol=1e-8) for existing in positions):
                        positions.append(position)


    # Escrever no arquivo no formato LAMMPS
    with open(output_file, "w") as f:
        f.write(f"LAMMPS data file for doped graphene\n\n")
        f.write(f"{len(positions)} atoms\n")
        f.write(f"2 atom types\n\n")
        f.write(f"{-nx_negative * np.linalg.norm(vectors[0]):.6f} {(nx_positive+1) * np.linalg.norm(vectors[0]):.6f} xlo xhi\n")
        f.write(f"{-(ny_negative) * np.linalg.norm(vectors[1]):.6f} {(ny_positive) * np.linalg.norm(vectors[1]):.6f} ylo yhi\n")
        f.write(f"{-nz_negative * np.linalg.norm(vectors[2]):.6f} {(nz_positive) * np.linalg.norm(vectors[2]):.6f} zlo zhi\n\n")
        f.write(f"Masses\n\n1 12.011\n2 14.007\n\nAtoms\n\n")
        for idx, pos in enumerate(positions, start=1):
            f.write(f"{idx} 1 {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n")



    print(f"Arquivo {output_file} gerado com sucesso! Total de {len(positions)} átomos.")


# Dados de exemplo
vectors = [
    [1.5, 0.866025403784439, 0.0],  # Vetor 1 (exemplo)
    [0.0, 1.732050807568878, 0.0],  # Vetor 2 (exemplo)
    [0.0, 0.0, 23.63098411]   # Vetor 3 (exemplo)
]

bases = [
    [0.0, 0.0, 0.0],
    [0.666668236, -0.333334118, 0.0],
    [1.333336472, -0.666668236, 0.1],
    [0.666668236, -0.333334118, 0.1]
]

repetitions = [0, 10, 0, 8, 0, 1]

lattice_param = 1.438789

generate_lammps_positions(vectors, bases, repetitions, output_file="grapheneN.data", lattice_param=lattice_param)

# Baixar o arquivo gerado
from google.colab import files
files.download("grapheneN.data")
